commit 1cd1c1d62edc6693a3854b22d53c9bbc1b149798
Author: serge-sans-paille <sguelton@redhat.com>
Date:   Tue Jul 14 14:23:14 2020 +0200

    Revert "[SCEV][IndVarSimplify] insert point should not be block front."
    
    This reverts commit f1efb8bb4ba0584a9b994f3404a2c62920ce6652.
    
    Reverted because it doesn't correctly update the pass return status, see
    
    http://lab.llvm.org:8011/builders/llvm-clang-x86_64-expensive-checks-debian/builds/9441/steps/test-check-all/logs/FAIL%3A%20LLVM%3A%3Awiden-i32-i8ptr.ll

diff --git a/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp b/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
index 0357d905fde..f6a0b6ea463 100644
--- a/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
+++ b/llvm/lib/Transforms/Scalar/IndVarSimplify.cpp
@@ -1435,12 +1435,8 @@ PHINode *WidenIV::createWideIV(SCEVExpander &Rewriter) {
   // either find an existing phi or materialize a new one. Either way, we
   // expect a well-formed cyclic phi-with-increments. i.e. any operand not part
   // of the phi-SCC dominates the loop entry.
-  Instruction *InsertPt = &*L->getHeader()->getFirstInsertionPt();
-  WidePhi = dyn_cast<PHINode>(Rewriter.expandCodeFor(AddRec, WideType, InsertPt));
-  // If the wide phi is not a phi node, for example a cast node, like bitcast,
-  // inttoptr, ptrtoint, just skip for now.
-  if (!WidePhi)
-    return nullptr;
+  Instruction *InsertPt = &L->getHeader()->front();
+  WidePhi = cast<PHINode>(Rewriter.expandCodeFor(AddRec, WideType, InsertPt));
 
   // Remembering the WideIV increment generated by SCEVExpander allows
   // widenIVUse to reuse it when widening the narrow IV's increment. We don't
diff --git a/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp b/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
index c54ae26b532..71b48482f26 100644
--- a/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
+++ b/llvm/lib/Transforms/Utils/ScalarEvolutionExpander.cpp
@@ -1292,8 +1292,7 @@ SCEVExpander::getAddRecExprPHILiterally(const SCEVAddRecExpr *Normalized,
   if (useSubtract)
     Step = SE.getNegativeSCEV(Step);
   // Expand the step somewhere that dominates the loop header.
-  Value *StepV = expandCodeFor(Step, IntTy,
-                               &*L->getHeader()->getFirstInsertionPt());
+  Value *StepV = expandCodeFor(Step, IntTy, &L->getHeader()->front());
 
   // The no-wrap behavior proved by IsIncrement(NUW|NSW) is only applicable if
   // we actually do emit an addition.  It does not apply if we emit a
@@ -1439,8 +1438,7 @@ Value *SCEVExpander::expandAddRecExprLiterally(const SCEVAddRecExpr *S) {
       {
         // Expand the step somewhere that dominates the loop header.
         SCEVInsertPointGuard Guard(Builder, this);
-        StepV = expandCodeFor(Step, IntTy,
-                              &*L->getHeader()->getFirstInsertionPt());
+        StepV = expandCodeFor(Step, IntTy, &L->getHeader()->front());
       }
       Result = expandIVInc(PN, StepV, L, ExpandTy, IntTy, useSubtract);
     }
@@ -1872,6 +1870,11 @@ Value *SCEVExpander::expand(const SCEV *S) {
     }
   }
 
+  // IndVarSimplify sometimes sets the insertion point at the block start, even
+  // when there are PHIs at that point.  We must correct for this.
+  if (isa<PHINode>(*InsertPt))
+    InsertPt = &*InsertPt->getParent()->getFirstInsertionPt();
+
   // Check to see if we already expanded this here.
   auto I = InsertedExpressions.find(std::make_pair(S, InsertPt));
   if (I != InsertedExpressions.end())
@@ -1942,8 +1945,7 @@ SCEVExpander::getOrInsertCanonicalInductionVariable(const Loop *L,
   // Emit code for it.
   SCEVInsertPointGuard Guard(Builder, this);
   PHINode *V =
-      cast<PHINode>(expandCodeFor(H, nullptr,
-                                  &*L->getHeader()->getFirstInsertionPt()));
+      cast<PHINode>(expandCodeFor(H, nullptr, &L->getHeader()->front()));
 
   return V;
 }
diff --git a/llvm/test/Transforms/IndVarSimplify/widen-i32-i8ptr.ll b/llvm/test/Transforms/IndVarSimplify/widen-i32-i8ptr.ll
deleted file mode 100644
index 80191d4e5b7..00000000000
--- a/llvm/test/Transforms/IndVarSimplify/widen-i32-i8ptr.ll
+++ /dev/null
@@ -1,24 +0,0 @@
-; RUN: opt < %s -indvars -S | FileCheck %s
-
-target datalayout = "e-m:e-i64:64-n32:64"
-
-define dso_local void @Widen_i32_i8ptr() local_unnamed_addr {
-; CHECK-LABEL: @Widen_i32_i8ptr(
-; CHECK: phi i8*
-; CHECK: phi i32
-entry:
-  %ptrids = alloca [15 x i8*], align 8
-  %arraydecay2032 = getelementptr inbounds [15 x i8*], [15 x i8*]* %ptrids, i64 0, i64 0
-  store i8** %arraydecay2032, i8*** inttoptr (i64 8 to i8***), align 8
-  br label %for.cond2106
-
-for.cond2106:                                     ; preds = %for.cond2106, %entry
-  %gid.0 = phi i8* [ null, %entry ], [ %incdec.ptr, %for.cond2106 ]
-  %i.0 = phi i32 [ 0, %entry ], [ %inc2117, %for.cond2106 ]
-  %incdec.ptr = getelementptr inbounds i8, i8* %gid.0, i64 1
-  %idxprom2114 = zext i32 %i.0 to i64
-  %arrayidx2115 = getelementptr inbounds [15 x i8*], [15 x i8*]* %ptrids, i64 0, i64 %idxprom2114
-  store i8* %gid.0, i8** %arrayidx2115, align 8
-  %inc2117 = add nuw nsw i32 %i.0, 1
-  br label %for.cond2106
-}
